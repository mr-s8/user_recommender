- add common likes to the calculation (including profile posts?)
- complete admin panel (calculation timeframe (if 0 choose until last generation??), enable filter step, functionality for existing fields)
- filter out inactive users before calculation
- secure routes
- not interested should do more than just delete once
- add popup to the widget that shows link to survey
- make widget non blocking
- highlight very similar recommendations, that show for both
- race condition/possible unwanted behavior when generateForUser and generateForAllUsers run at same/similar time -> lock/transactions
- when normalisation?
- Error Handling
- choose good Fallback options
- dont calculate cosine similarity twice for a user pair
- when the user deletes all recommendations they get recalculated automatically, possibly unwanted
- choose way of storing last generation timestamp for cron check
- really use transactions for generation service? does that make it slow? use try catch without transaction instead?

-----
in die helper klasse neue funktion: getCommonLikes(user, target, spaceIds) returnt für die space id die common likes und ggf noch die commem profile post likes
klären ob die addition im nachhinein auch funktioniert wenn schon vorher normalisiert wurde

oder einfach nur für alle berechnen? neue nutzer, und auch inaktive haben ja keine aktivität, die kriegen dann eh fallback, also einfach direkt fallback ohne access?
wie kann ich generell nutzer ohne aktivität im zeitraum rausfiltern? 
dann auch nach der berechnung direkt mit thresh raufiltern? dann kann man einfach sagen, wenn kein eintrag in recommendations, kommt fallback.

wie wirds gemacht: es werden nur die recommendations in der datenbank gespeichert dessen wert größer gleich dem threshold ist. wenn es gar keine sind werden genereateCount viele Fallbacks geholt,
das widget heißt dann "interessante nutzer", so werden die targets nicht überfordert und der nutzer kann sich trotzdem zurechtfinden auf der plattform; wenn es recommendations gibt aber weniger als generate
count wird die differenz mit fallbacks gefüllt wobei die echten recommendations besser im toShow part sein sollten;
wenn das implementiert ist kommt der shuffle mechanismus

was soll der fallback werden? einfach die nutzer mit der addiert höchsten activity? und dann einfach generation count viele?

das problem mit den unendlichen regenerations fällt dann auch weg. er schaut dann halt nach und gibt trotzdem fallback.

um zu verhindern dass immer die selben fallback sind, limit*1,5 gerundet und dann shufflen und nur limit zurückgeben

der shuffle mechanismus für fallbacks auch für die richtigen generations geeignet? oder nur raw shuffle oder wie? für mehr exploration oder so vlt? ka oder auch so neue reinstreuen? ka aufjedenfall soll auf coco nicht immer das gleiche
angezeigt werden also macht das schon bisschen sinn...

reihenfolge der widget noch machen. bei shuffle egal, aber bei sortiert sollen richtige zuerst nach score und dann erst fallbacks nach score

es darf keine doppelten recs geben!! die bei der query die recs mitschicken, gibt ja genug fallbacks eigentlich

warum sind die recs für mich verschwunden? gibts einen bug?? im auge behalten; db logs?

und warum wird der sql fehler auf den bildschirm ausgegeben???

nochmal alles durchgehen prüfen, ggf sql anfragen alle angleichen

db aktionen undso alle testen, die geben manchmal keinen fehler. besonders bei datumsformaten undso....


das normalisieren, passt das so?? das mal überprüfen, weil das mit köller und schäfer ist schon weird... obwohl die länge der vektoren ist ja egal eigentlich...

exploration vs exploitation?

--
next up: rendering richtig, lookback übers settings, multiplier für normal knn recs, opt cosine sim, common likes, filter step, secure routes






------

die recommendations werden geholt, wenn keine da, dann halt nur fallbacks nehmen, wenn weniger als generationCount viele recommendations mit noch nicht in den recommendations vorhandenen fallback usern auffüllen.
wenn shuffle aus den settings an ist (feld heißt shuffleRecommendations), dann nur sicherstellen, dass die nicht fallback recommendations auf der ersten seite sind (dürfen aber gerne durchmisch sein mit den fallbacks), 
wenn shuffle aus ist, kommen erst die richtigen recs nach score sortiert und dann die fallback recs nach deren score sortiert

das was in die render funktion soll schon im service machen? und dann in den recommendations nach fallback gucken?, ne das ist dann sehr viel datenbank clutter, die sind doch global;

so üblich dass man die sachen vom frontend übernimmt? der könnte ja einfach eine andere id nehmen und das logging beeinflussen

ab wie vielen fallbacks soll der name des widgets zu interesting users geändert werden; damit auch die nutzer nicht zu doll angefragt werden


wenn not interested die recommendations löscht, dann kann der rejectete user wieder durch die fallbacks kommen, darauf muss geachtet werden; aber soll irgendwann überhaupt fallback kommen? oder reicht einfach?

---


widget soll nicht blocken,  common likes (normalisation problem?), filter step und opt cosine, secure routes, Unfollowed Priority Count?? (mit thresh für unfollowed user - wie man maximal runtergeht mit ähnlichkeit),
auch only show unfollowed users option? mal sehen, tickbox vlt??

gutes logging, code comments auf englisch



done aber noch testen am besten: dynamic widget title, lookback über settings, multiplier for knn recs, multiplier über settings



eine optimierung war einmal zu normalisieren; vlt optional common likes?


bei unfollowed priority count noch: min similairty threshold und vlt force unfollowed

dies forcen geht ja auch nicht weil fallbacks kommen

-------------

mitloggen ob ungefolgt oder nicht? ist ja eigentlich, dann ist die anfrage ez

paar mehr fallbacks generieren, damit man nicht zu wenige recs bekommt wenn ähnliche und fallbacks die selben sind? aber das ist ja auch nur der fall wenn es weniger als n fallbacks gibt, also nicht zu beachten warhscheinlich

scores in einer neuen liste oder einer vorhandenen speichern für opt?

widget evtl togglen

validate every user input

globale und lokale liste und auf kopien arbeiten alles richtig?
werden immer kopien erzeugt bei funktionsaufruf? ist das schlimm? sollten andere listen global sein?

-----------
cronjob zum laufen brinden
filter step??  (wenn summe von activities kleiner als? neuer thresh in den settings??)#
optimize pairs#
gutes dev loggin (vlt nur für user id 1, damit überschaubar)
widget non blocking
save rec history
error handling
wie wiederholten recs entgegenwirken?#
int datum fixen
secure routes
unfollowed prio count, und force option (neuer thresh??)#
code comments
exploration vs exploitation
umfrage popup
log clicks bug? #
followed mitloggen; aber dann was zum zeitpunkt der berechnung war und nicht zum logzeitpunkt oder?

absatz über pearson vs cosine similarity
was dies item based


ich habe zu wenig vorschläge und werde mir selber vorgeschlagen...
letzteres weil man selber aus seinen fallbacks nicht ausgeschlossen wird? #, gelöst, ersteres normales verhalten wahrscheinlich

shuffle shufflet das bei jedem neuladen; vlt nach abc und nicht nach score? aber egal sonst


ansatt für jedes paar sql abfrage, alle followed user returnen

-----------------------
unfollowed opt#
save last 5 rec history; mit unfollowed? gibt kein datum, aufjedenfall mitloggen (dies und das obere irgendwie zusammen)#

cronjob
dev logging
widget non blocking
int datum fixen#
code comments
umfrage popup
validate user input and secure routes

(widget togglen)


themen: pearson, item based, exploration/exploitation


schreiben in funktionsaufrufen auch teil der transaktion? tue ich das überhaupt?

admin panel anpassen, mind unfollowed und fields weg

alle created at gleiches format?

fallback tabelle wird immer länger, 


reciprocal noch machen?

-----------

onCron hook in module php

use humhub\modules\cron\events\CronEvent;
use humhub\modules\cron\jobs\CronJob;

public function init()
{
    parent::init();

    \Yii::$app->on(CronEvent::EVENT_ON_HOURLY_RUN, function (CronEvent $event) {
        $event->addJob(new CronJob([
            'route' => 'meinmodul/cron/run',
        ]));
    });
}



--
als mögliche verbesserung die loading sachen schon vorher machen, und vorallem nicht jedes mal oder zumindest lazy loading

was wenn es mehr recs gibt als man braucht

click log bei rejection gefixt


showsurveyinfo null#
http link profile image?
fallback tabelle
cronjob#

prettyurl #


use cron mutex?

------------

cron logik1#




csrf#

fallback tabelle#

lazyloading2#

reciprocal#

schreiben in funktionsaufrufen auch teil der transaktion? tue ich das überhaupt?

dev logging

code comments3

admin panel verbesserns#




----------
wie soll ich user data test machen? neue option start zeit punkt. aber nur für dev oder?

einfach gucken ob in den letzten 20 stunden ein run war, wenn nein schauen ob jetzt oder in den letzten 2h einer hätte sein sollen.

fallback thresh geht nicht ganz? bei 0#

20 period verkürzen? da sonst evtl bei umstellung der zeit nicht geht

ähnleichkeit für ungefolgte nicht für eh schon dae; neue def checken#

dp reciprocal
reciprocal schwelle immer höher als normale

activity cleanen? und extra tabelle für rejections eigentlich; aber vlt einfach in docs reinschreiben


following in activity tabelle rein?






--------------
following und reciprocal in activity tabelle#
fehlerbehandlung route
schreiben in funktionsaufrufen auch teil der transaktion? tue ich das überhaupt?
code comments
dev logging
cron period verkürzen?

wie activity cleanen; und brauche ich extra tabelle für rejections?
regel für reciprocal thresh?


reject auf reciprocal loggt nicht und dann kommt er als nicht reciprocal wieder!!!! ;; jetzt kommt der normale auch wieder
> del ging, dann fehler wegen var name und dann das reject loggen kam nicht mehr, sodass der als fallback wieder kam
und komisches tooltip behavior? vlt wenn der gerade wegrutscht


warum aufeinmal hans peter und warum hat stephan schäfer mich nicht mehr als rec
ersteres: ich folge jetzt köller und die schwelle für ungefolgte ist 0 und hans peter hat mich halt auch als rec; letzteres keine ahnung gerade

ist die follows beziehung vertauscht? irgendwo vlt? oder params vertauscht? oder auch die rejection beziehung?? das eigentlich nicht, weil der lookback auf 0 ist

stephan schäfer wird mir auch als fallback angezeigt... die frage ist also warum wird er mir nicht normal vorgeschlagen? wird er wegen unfollowed oder so aussortiert?
weil ich ihm folge wird er irgendwie aussortiert? vlt funktioniert die unfollowed prio sache bei zu wenig usern nicht; ja das wars!


kann man beim replacen mit den unfollowed users wieder andere unfollowed user rauskicken?; ja konnte man, sollte gefixt sein...


---

fehlerbehandlung route
schreiben in funktionsaufrufen auch teil der transaktion? tue ich das überhaupt?
code comments#
dev logging
cron period verkürzen?

wie activity cleanen; und brauche ich extra tabelle für rejections?
regel für reciprocal thresh?

bessere transaction vlt

saveRecommendations löscht nur pro user id immer; wenn ein user die plattform verlässt, bleibt die rec für immer? oder wird wo anders gelöscht?















___

pratvish sagen dass: evtl bessere fehlerbehandlung in den routen; activity table not cleaned (for thesis wouldnt want it cleaned, but afterwards...) but its hard to - mby define a max number of cooldown runs;
saverecommendations "problem", that only everything gets deleted once for a user, and if a user leaves it will stay there for ever (mby solve with created at...);

















------------------


// wenn der user die zeit auf 12 uhr setzt der hourly run aber erst um 12:20 ist, oder der check ein paar sekunden braucht, dann ist evtl schon ein anderer wochentag. wenn die - toleranz groß genug ist, sollte das trotzdem gehen, eigentlich will ich dass der job aber auch wirklich erst ab der uhrzeit laufen
// kann.
//wenn wenn das kurz vor 12 ausgelöst wird, der run aber gerade am nächsten tag startet ist für diesen tag keine ausführung mehr möglich. man könnte evtl nur immer die letzten 5h anschauen oder so, aber ich weiß nicht ob das die sauberste lösung wäre.





// vlt sogar timestamp am anfang von run methode setzen? dann nicht lastRun sondern last check? aber das geht dann glaube nicht mehr
// aber schauen ob safe
// eher queue machen? ne das ist keine garantierte uhrzeit dann
// last time über tabelle holen? dann zählen auch manuelle mit; kann die generateall funktion dann abbrechen und der cronjob macht das dann trotzdem noch weiter wenn das in der toleranzzeit ist? ist aber wenn dann auch nicht verlässlich

// prüfen ob heute - wenn sich das so verschiebt dass es gerade so schon am nächsten tag lief?; und soll ich nur + toleranz machen?// oder kann das auch so schon wegen toleranz am nächsten tag erst laufen und dann gar nicht?; dann dock +-?
// wenn der cronjob um 12 auslösen soll kann es auch 12:01 sein, dann ist der wochentag schon vorbei



// recommendedUserIds und generationId als transaction? was wenn neu generiert wird bei abfrage? der all job läuft schon als transaction, vlt blockt das aber schon, aber ist das gewollt?